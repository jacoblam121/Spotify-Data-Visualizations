https://www.youtube.com/watch?v=psUn1NVpebw&t=2s

A Python project that takes your Last.fm listening history for 2024, processes it, and generates a dynamic bar chart "race" video of your top 10 songs throughout the year complete with album covert art. 

## Demo Output

Generates an MP4 video file named `spotify_top_songs_2024_4k.mp4`. 
Mine is currently in the repo with this name, but will overwrite if you decide to run locally.

*(Consider adding a GIF or a link to a sample video here if you have one)*

## Project Structure

```
spotify2024/
├── .venv/                   # Virtual environment
├── album_art_cache/         # Downloaded album cover art and MBIDs
│   ├── mbid_cache.json
│   └── dominant_color_cache.json
├── fonts/                   # Fonts (helps with foreign characters)
├── main_animator.py         # Main as well as runs the animation
├── data_processor.py        # Data cleaning / preparation
├── album_art_utils.py       # Functions for fetching album art and colors (done calling MusicBrainz api)
├── lastfm_data.csv          # Your Last.fm listening history (UTF-8 encoded CSV)
├── README.md                # This file
└── (other generated files like .mp4 output)
```

## Prerequisites/Requirements

1.  **FFmpeg**: needed to save animation as mp4
    *   Download from [https://ffmpeg.org] and add to path
2.  **Python Dependencies:**
    pandas
    matplotlib
    Pillow
    requests
3.  **Last.fm Data:**
    *   Download from [https://lastfm.ghan.nl/export/]
    *   Name the file `lastfm_data.csv` and place it in the project directory
4. **API Configuration:**
    *   Make sure the `USER_AGENT` in `album_art_utils.py` is set to your own email address for API calls
    *   So replace `lightningfalconyt@gmail.com` with your email
5. **Run**
    *   Make sure to use terminal (not "output" in VSCode)
    *   utf-8 is necessary if music has foreign characters

    Command Prompt (cmd):
    ```shell
    set PYTHONIOENCODING=utf-8
    python "path\to\your\project\directory\main_animator.py"
    ```
    PowerShell:
    ```shell
    $env:PYTHONIOENCODING="utf-8"
    python "path\to\your\project\directory\main_animator.py"
    ```

    *   Rendering takes around 40 minutes on my machine (only uses cpu, no gpu encoding so its pretty unoptimized lol)

## Configuration

You can adjust some settings by changing the constants at the top of `main_animator.py` and `album_art_utils.py`.

### In `main_animator.py`:

*   **N_BARS**: `10`  
    Number of top songs to display in the bar chart
*   **TARGET_FPS**: `30`  
    FPS for video (higher means longer rendering time)
*   **ANIMATION_INTERVAL**: `1000 / TARGET_FPS`  
    Milliseconds between animation frames.
*   **OUTPUT_FILENAME**: `"spotify_top_songs_2024_4k.mp4"`  
    Name of video file.
*   **VIDEO_RESOLUTION_WIDTH**: `3840`  
    Width of output video (pixels)
*   **VIDEO_RESOLUTION_HEIGHT**: `2160`  
    Height of output video (pixels)
*   **VIDEO_DPI**: `165`  
    Dots Per Inch for the Matplotlib plot rendering; impacts relative size of graph and text
*   **DEBUG_CACHE**: `True`  
    Set to `False` to disable debug messages for album art pre-fetching
*   **plt.rcParams['animation.ffmpeg_path']**: commented out  
    Uncomment if having trouble setting ffmpeg to path
*   **PREFERRED_FONTS**: `['DejaVu Sans', 'Noto Sans JP', ...]`  
    Font list

### In `album_art_utils.py`:

*   **DEBUG_CACHE**: `True`  
    Set to `False` to disable console logging for MusicBrainz ID (MBID) caching, dominant color caching, and image download caching

## How It Works (generated by AI)

1.  **Data Loading & Cleaning (`data_processor.py`):**
    *   Loads `lastfm_data.csv`.
    *   Converts Unix timestamps to datetime objects.
    *   Filters data for the year 2024.
    *   Cleans data by dropping rows with missing essential information (artist, album, track).

2.  **Data Preparation for Race (`data_processor.py`):**
    *   Creates a unique `song_id` (Artist - Track).
    *   Maps `song_id` to album names.
    *   Generates a "race-ready" DataFrame where:
        *   Index: Timestamps of each individual play event (for smooth animation).
        *   Columns: Unique `song_id`s.
        *   Values: Cumulative play counts for each song at that exact timestamp. This involves pivoting and forward-filling play counts.

3.  **Album Art & Color Fetching (`album_art_utils.py`):**
    *   For each unique album, it tries to find a MusicBrainz Release ID (`mbid`).
    *   Uses the `mbid` to query the Cover Art Archive for an album art URL.
    *   Downloads the album art and saves it to the `album_art_cache` directory.
    *   Calculates the dominant color from the downloaded album art using Pillow.
    *   MBIDs, image paths, and dominant colors are cached in JSON files (`mbid_cache.json`, `dominant_color_cache.json`) and the `album_art_cache` folder to avoid re-fetching on subsequent runs.

4.  **Animation (`main_animator.py`):**
    *   Initializes a Matplotlib figure and axes.
    *   Pre-fetches album art and dominant colors for songs appearing in the race.
    *   The `draw_frame` function is called for each frame (each play event timestamp):
        *   It gets the top N songs by play count at that specific timestamp.
        *   Draws horizontal bars for these songs.
        *   Sets the bar color using the cached dominant color for the song's album.
        *   Overlays album art (if found) next to the corresponding bar.
        *   Updates the date/time counter on the animation.
    *   Uses `matplotlib.animation.FuncAnimation` to create the animation.
    *   Saves the animation as an MP4 file using FFmpeg.
